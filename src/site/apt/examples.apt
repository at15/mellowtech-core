%{toc|fromDepth=1|toDepth=3}

Byte Based Object

  As was explained in the introduction Mellowtech Core is basically an API
  for supporting the developer in situations when in memory is not enough,
  e.g. objects needs to have a byte based representation.

  In Java this is typically achieved with the Serialization API so why did we
  create an alternative? First and foremost, it was because of speed and to
  force a programmer to implement the necessary methods. Second, to a large
  extend Mellowtech Core works directly on ByteBuffers and the normal
  Serialization API does not have in-built support for that. Finally, we also
  wanted a way of comparing objects on a byte level, again something that the
  Serialization API does not support.

  Today there are very good alternatives to the in-built Serialization API, such as,
  Google's Protobuf protocol. We are looking into how Mellowtech Core can support
  that.

  Before we go on you should note that you would typically not have to create your
  own ByteStorable objects since the API comes with a lot of...


* Using Built in ByteStorables

  The library comes with a set of built in ByteStorable types to handle most
  situations that you would need when serializing objects. The primitive types are:

  * CBBoolean - stores a boolean

  * CBByte - stores a Byte

  * CBChar - stores a Character

  * CBShort - stores a short

  * CBInt - stores an int

  * CBLong - stores a long

  * CBFloat - stores a float

  * CBDouble - stores a double

  * CBString - stores a String

  * CBByteArray - stores a byte\[\]

  []

  In addition to the primitive types you also have the following in-builts

  * CBList - implements the List Interface

  * CBMap - implements the map Interface

  * CBSortedMap - implements the map Interface

  * CBPrimitiveObject - can hold any of the above

  * CBAuto - base class for building complex types

  []

  In the first example we simply use the API to serialize an integer and
  read it back again.

%{snippet|id=ex1-serialize|url=http://www.mellowtech.org/svn/core/trunk/src/main/java/com/mellowtech/core/examples/Example1.java}

  In the second example (below) we are using the CBMixedList to store a list
  of primitive ByteStorables.

%{snippet|id=ex1-list|url=http://www.mellowtech.org/svn/core/trunk/src/main/java/com/mellowtech/core/examples/Example1.java}

  It is easy to see how you can use ByteStorables as a way of doing deep copies

+---
ByteBuffer bb = byteStorable.toBytes();
bb.flip();
byteStorable.fromBytes(bb, true)
+---

  creates a true copy of your object. Since this is a common function it is also
  directly implemented in ByteStorable as

+---
ByteStorable copy = byteStorable.deepCopy();
+---

* Creating Complex ByteStorables

  In many situations using the in-built ByteStorables are enough. However, if
  you need a more complex structure you will have to implement it. Again,
  this is the difference from e.g. java.io.Serializable. It is a little
  bit more work but it typically offers better performance. <ByteStorable>
  contains a lot of methods to assist the developer. At a minimum you are
  required to implement four methods and the empty constructor in your subclass.

%{snippet|id=c1-class|url=http://www.mellowtech.org/svn/core/trunk/src/main/java/com/mellowtech/core/examples/Container1.java}

  A couple of important things to note when you create your own ByteStorables

  [[1]] You have to be able to determine the byte size within the first 4 bytes of
  the serialized object (that is why we include a size indicator

  [[2]] When calculating the byteSize don't forget to include any bytes that
  a size indicator would occupy (that is why we added 4 in the <byteSize()> method

  [[3]] When reading the byteSize from a ByteBuffer your ByteStorable should
  not change the position in the ByteBuffer (that why we used the utility
  function <getSizeFour()>

  [[4]] ByteStorables should implement the empty constructor

  [[5]] The get/set methods are overwritten when your ByteStorable acts as a
  wrappper for another object (e.g. new CBInt(1).get() returns an Integer)
  []

  In most situations implementing the above 4 methods are fine. However,
  if you need to fine tune the performance it might make sense to override
  the other from/to byte methods

* Using CBAuto

  As an alternative to the above pattern where you implement the to/from bytes yourself
  you can use the CBAuto class if you need to a complex object. The only thing to watch
  out for is that it only supports the built-in ByteStorables. The above class would
  be implemented using CBAuto in the following way:

%{snippet|id=c2-class|url=http://www.mellowtech.org/svn/core/trunk/src/main/java/com/mellowtech/core/examples/Container2.java}

  Observe that you always need to specify an index in your BSField annotation.

* Comparing Using ByteStorable

  The original (and still) main purpose of the Mellowtech Core library
  was to offer functionality to sort and store objects on disc. In order
  to do this we have to be able to compare objects. In many situations
  the following would be sufficient

  <new CBString("string").get().equals("string")>

  That is, you do your comparison on an object level. However, if you many
  million objects that have been serialized this might scheme might impact
  performance quite a bit if you constantly have to create objects when
  doing comparisons.

  <ByteComparable> allows do do object comparison on a byte level. All in-built
  ByteStorables (apart from CBMixedList) are also ByteComparables.

%{snippet|id=ex2-compare|url=http://www.mellowtech.org/svn/core/trunk/src/main/java/com/mellowtech/core/examples/Example2.java}

  So in the above example comparison will be done purely on a ByteBuffer
  level without first extracting the strings.

Block Files



BTrees and HashMaps

Disc Based Map API

 The second example is the disc based map structure.

Sorting

  Mellowtech core contains a powerful sorting library for sorting large scale.

Caching